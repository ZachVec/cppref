#!/usr/bin/env python3

import asyncio
import sys
from subprocess import Popen

from tqdm import tqdm

from cppref import Record, Source
from cppref.conf import ConfContext
from cppref.fzf import FzfContext
from cppref.utils import Utils


class CppRef:
    def switch(self, source: Source):
        with ConfContext() as conf:
            conf.source = source

    def list(self):
        source = ConfContext.read_source()
        try:
            records = Utils.query(source, ConfContext.dbfile())
            print("\n".join(map(str, records)))
        except AssertionError as e:
            print(str(e), file=sys.stderr)
        except BrokenPipeError:
            pass  # the process piped to has been closed.

    def man(self, *, timeout: float = 10000):
        source = ConfContext.read_source()
        dbfile = ConfContext.dbfile()
        man3 = ConfContext.man3_root()
        html = ConfContext.html_root()

        try:
            records = Utils.query(source, dbfile)
        except AssertionError as e:
            return print(str(e), file=sys.stderr)

        with FzfContext("+m") as fzf:
            assert fzf.add_option(*records)
            selected = fzf.get_selection()
            if len(selected) == 0:
                return print("Canceled.")
            record = records[Record.parse_id(selected[0]) - 1]

        filename = man3.joinpath(f"{source}{record.id}.3.gz")
        filename.parent.mkdir(parents=True, exist_ok=True)

        if not filename.exists():
            htmlname = html.joinpath(f"{source}{record.id}.html")
            if htmlname.exists():
                webpage = Utils.read_file(htmlname)
            else:
                webpage = Utils.fetch(record, timeout)

            Utils.write_file(filename, Utils.html_handler(source)(webpage, record))

        process = Popen(f"man {filename}", shell=True)
        process.wait()

    def fetch(self, *, force: bool = False, timeout: float = 10000, limit: int = 5):
        source = ConfContext.read_source()
        html = ConfContext.html_root()

        # Get required records
        try:
            records = Utils.query(source, ConfContext.dbfile())
        except AssertionError as e:
            return print(f"Unexpected Error: {e}", file=sys.stderr)
        if not force:
            records = list(filter(lambda r: not html.joinpath(f"{source}{r.id}.html").exists(), records))  # fmt: off
            records = list(records)
        records = list(records)
        if len(records) == 0:
            return print("Nothing to fetch.", file=sys.stderr)

        # Process
        async def _fetch(records: list[Record]):
            index, total = -1, len(records)
            async for resp in Utils.afetch(*records, timeout=timeout, limit=limit):
                index += 1
                if isinstance(resp, BaseException):
                    print(f"Error={type(resp).__name__}({str(resp)}), record={records[index]}", file=sys.stderr)  # fmt: off
                    continue
                Utils.write_file(html.joinpath(f"{source}{records[index].id}.html"), resp)  # fmt: off
                print(f"{index}/{total}", file=sys.stdout)

        html.mkdir(parents=True, exist_ok=True)
        asyncio.run(_fetch(records))

    def parse(self, force: bool = False, interact: bool = False):
        source = ConfContext.read_source()
        html = ConfContext.html_root()
        man3 = ConfContext.man3_root()
        if not html.exists():
            return f"{html} is not eixst, run cache command first."
        if not html.is_dir():
            return f"{html} is not a directory"

        # Get required records
        try:
            records = Utils.query(source, ConfContext.dbfile())
        except AssertionError as e:
            return print(str(e), file=sys.stderr)
        records = list(filter(lambda r: html.joinpath(f"{source}{r.id}.html").exists(), records))  # fmt: off
        if interact:
            with FzfContext("-m") as fzf:
                assert fzf.add_option(*records)
                selected = fzf.get_selection()
                records = [records[Record.parse_id(s) - 1] for s in selected]
        elif not force:
            records = list(filter(lambda r: not man3.joinpath(f"{source}{r.id}.3.gz").exists(), records))  # fmt: off
        if len(records) == 0:
            return print("Nothing to parse.")

        # Parse
        man3.mkdir(parents=True, exist_ok=True)
        total, process = len(records), Utils.html_handler(source)
        for r in tqdm(records, desc="Processing", total=total, file=sys.stdout):
            document = Utils.read_file(html.joinpath(f"{source}{r.id}.html"))
            try:
                document = process(document, r)
            except AssertionError as e:
                print(f"{e}, record={r}", file=sys.stderr)
            except Exception as e:
                print(f"record={r}, Unexpected error {e}", file=sys.stderr)
            else:
                Utils.write_man3(man3.joinpath(f"{source}{r.id}.3.gz"), document)


if __name__ == "__main__":
    import fire

    fire.Fire(CppRef, name="cppref")
