#!/usr/bin/env python3

import asyncio
import os
import sys
from enum import Enum
from pathlib import Path
from types import NoneType
from typing import Callable, Optional, overload

from tqdm import tqdm
from tqdm.asyncio import tqdm_asyncio as atqdm

from cppref import Configuration, Format, Record, Source, Utils

DATA_HOME = Path(os.getenv("XDG_DATA_HOME") or "~/.local/share").joinpath("cppref")
DATA_DIR = str(DATA_HOME)


class ErrorCode(Enum):
    DATABASE_NOT_EXIST = "index.db not exist, download it from github."
    PKEY_NOT_EXIST = "entry not found with provided information"


class CppRef:
    def __init__(self) -> None:
        state = Path(os.getenv("XDG_STATE_HOME") or "~/.local/state")
        state = state.joinpath("cppref", "cppref.toml").expanduser().absolute()
        state.parent.mkdir(parents=True, exist_ok=True)
        self._conf_path = state

    @staticmethod
    def _non_exist_filter(dir: Path, ext: str):
        def filter_fn(record: Record) -> bool:
            return not dir.joinpath(f"{record.id}.{ext}").exists()

        return filter_fn

    @staticmethod
    def _exist_filter(dir: Path, ext: str):
        def filter_fn(record: Record) -> bool:
            return dir.joinpath(f"{record.id}.{ext}").exists()

        return filter_fn

    @overload
    def _query(self, conf: Configuration, pkey: int) -> Record | ErrorCode: ...

    @overload
    def _query(
        self, conf: Configuration, pkey: NoneType = None
    ) -> list[Record] | ErrorCode: ...

    def _query(
        self, conf: Configuration, pkey: Optional[int] = None
    ) -> list[Record] | Record | ErrorCode:
        db = Path(conf["db_path"])
        if not db.exists() or not db.is_file():
            return ErrorCode.DATABASE_NOT_EXIST
        results = list(Utils.query(conf["source"], pkey=pkey, path=db))
        if pkey is None:
            return results
        if len(results) == 0:
            return ErrorCode.PKEY_NOT_EXIST
        return results[0]

    def switch(self, source: Source):
        with Configuration(self._conf_path) as conf:
            conf["source"] = source

    def list(self):
        with Configuration(self._conf_path) as conf:
            records = self._query(conf)
            if isinstance(records, ErrorCode):
                return print(records.value, file=sys.stderr)
            return "\n".join(map(str, records))

    def man(self, pkey: int, *, dir: str = DATA_DIR, timeout: float = 10):
        with Configuration(self._conf_path) as conf:
            root = Path(dir).expanduser().joinpath(conf["source"])
            manp = root.joinpath("man")
            html = root.joinpath("html")

            filename = manp.joinpath(f"{pkey}.man")
            filename.parent.mkdir(parents=True, exist_ok=True)

            if not filename.exists():
                htmlname = html.joinpath(f"{pkey}.html")
                if htmlname.exists():
                    with open(htmlname, "r", encoding="utf-8") as file:
                        webpage = file.read()
                else:
                    record = self._query(conf, pkey)
                    if isinstance(record, ErrorCode):
                        return print(record.value, file=sys.stderr)
                    webpage = Utils.fetch(record, timeout)

                content = Utils.html_handler(conf["source"])(webpage)
                with open(filename, "w", encoding="utf-8") as file:
                    file.write(content)

    def cache(
        self,
        *,
        dir: str = DATA_DIR,
        format: Format = "man",
        force: bool = False,
        timeout: float = 10,
        limit: int = 30,
    ):
        """Fetch all documents and save as specified format.

        Args:
            dir: documents are stored under `dir/source/format/`
            format: "man" for manual or "html" for html documents
            force: overwrite the file if exists.
        """

        ext: str = format

        async def _cache(
            root: Path, records: list[Record], handler: Callable[[str], str]
        ):
            index = -1
            resps = Utils.afetch(*records, timeout=timeout, limit=limit)
            async for resp in atqdm(resps, desc="Processing", total=len(records), file=sys.stdout):
                index += 1
                resp = await resp
                if isinstance(resp, BaseException):
                    print(resp, file=sys.stderr)
                    continue
                try:
                    resp = handler(resp)
                except AssertionError as e:
                    print(str(e), file=sys.stderr)
                else:
                    filename = root.joinpath(f"{records[index].id}.{ext}")
                    with open(filename, "w", encoding="utf-8") as file:
                        file.write(resp)

        with Configuration(self._conf_path) as conf:
            records = self._query(conf)
            if isinstance(records, ErrorCode):
                return print(records.value, file=sys.stderr)

            root = Path(dir).expanduser().joinpath(conf["source"]).joinpath(format)
            if not force:
                records = list(filter(CppRef._non_exist_filter(root, ext), records))

            root.mkdir(parents=True, exist_ok=True)
            asyncio.run(_cache(root, records, Utils.html_handler(conf["source"])))

    def parse(self, dir: str = DATA_DIR, force: bool = False):
        with Configuration(self._conf_path) as conf:
            root = Path(dir).expanduser().joinpath(conf["source"]).absolute()
            html = root.joinpath("html")
            manp = root.joinpath("man")
            if not html.exists():
                return f"{html} is not eixst, run cache command first."
            if not html.is_dir():
                return f"{html} is not a directory"

            records = self._query(conf)
            if isinstance(records, ErrorCode):
                return print(records.value, file=sys.stderr)
            records = list(filter(CppRef._exist_filter(html, "html"), records))
            if not force:
                records = list(filter(CppRef._non_exist_filter(manp, "man"), records))

            process = Utils.html_handler(conf["source"])
            manp.mkdir(parents=True, exist_ok=True)
            for r in tqdm(records, desc="Processing", total=len(records), file=sys.stdout):
                document = Utils.read_file(html.joinpath(f"{r.id}.html"))
                try:
                    document = process(document)
                except AssertionError as e:
                    print(f"{e}, url={r.url}", file=sys.stderr)
                else:
                    Utils.write_file(manp.joinpath(f"{r.id}.man"), document)


if __name__ == "__main__":
    import fire

    fire.Fire(CppRef, name="cppref")
