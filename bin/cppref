#!/usr/bin/env python3

import asyncio
from subprocess import Popen
import sys
from pathlib import Path
from typing import Optional

from tqdm import tqdm
from tqdm.asyncio import tqdm_asyncio as atqdm

from cppref import Format, Record, Source
from cppref.conf import ConfContext
from cppref.fzf import FzfContext
from cppref.utils import Utils


class CppRef:
    def switch(self, source: Source):
        with ConfContext() as conf:
            conf.source = source

    def list(self):
        conf = ConfContext()
        try:
            records = Utils.query(conf.source, conf.dbfile)
            print("\n".join(map(str, records)))
        except AssertionError as e:
            print(str(e), file=sys.stderr)
        except BrokenPipeError:
            pass  # the process piped to has been closed.

    def man(self, *, dir: Optional[str] = None, timeout: float = 10000):
        with ConfContext() as conf:
            source = conf.source
            dbfile = conf.dbfile
            folder = Path(dir) if isinstance(dir, str) else conf.folder

        try:
            records = Utils.query(source, dbfile)
        except AssertionError as e:
            return print(str(e), file=sys.stderr)

        with FzfContext("+m") as fzf:
            assert fzf.add_option(*records)
            selected = fzf.get_selection()
            if len(selected) == 0:
                return print("Canceled.")
            record = records[Record.parse_id(selected[0]) - 1]

        root = folder.joinpath(source).expanduser().absolute()
        man3 = root.joinpath("man3")
        html = root.joinpath("html")
        filename = man3.joinpath(f"{record.id}.man")
        filename.parent.mkdir(parents=True, exist_ok=True)
        if not filename.exists():
            htmlname = html.joinpath(f"{record.id}.html")
            if htmlname.exists():
                webpage = Utils.read_file(htmlname)
            else:
                webpage = Utils.fetch(record, timeout)

            Utils.write_file(filename, Utils.html_handler(source)(webpage))

        process = Popen(f"man {filename}", shell=True)
        process.wait()

    def cache(self, *, dir: Optional[str] = None, format: Format = "man", force: bool = False, timeout: float = 10000, limit: int = 30):  # fmt: off
        with ConfContext() as conf:
            source = conf.source
            dbfile = conf.dbfile
            folder = Path(dir) if isinstance(dir, str) else conf.folder
            source_path = folder.joinpath(source).expanduser().absolute()

        ext: str = format
        if format == "man":
            _handler = Utils.html_handler(source)

            def handler(resp: str) -> str:
                return _handler(resp)
        else:

            def handler(resp: str) -> str:
                return resp

        root = source_path.joinpath(format)
        root.mkdir(parents=True, exist_ok=True)

        async def _cache(root: Path, records: list[Record]):
            index, total = -1, len(records)
            async for resp in Utils.afetch(*records, timeout=timeout, limit=limit):
                index += 1
                if isinstance(resp, BaseException):
                    print(f"Error={type(resp).__name__}({str(resp)}), record={records[index]}", file=sys.stderr)  # fmt: off
                    continue
                try:
                    resp = handler(resp)
                except AssertionError as e:
                    print(str(e), file=sys.stderr)
                    continue
                else:
                    Utils.write_file(root.joinpath(f"{records[index].id}.{ext}"), resp)
                    print(f"{index}/{total}", file=sys.stdout)

        try:
            records = Utils.query(source, dbfile)
        except AssertionError as e:
            return print(f"Unexpected Error: {e}", file=sys.stderr)

        if not force:
            records = filter(lambda r: not root.joinpath(f"{r.id}.{ext}").exists(), records)  # fmt: off
        records = list(records)
        if len(records) == 0:
            return print("Nothing to fetch.", file=sys.stderr)
        asyncio.run(_cache(root, list(records)))

    def parse(self, dir: Optional[str] = None, force: bool = False, interact: bool = False):  # fmt: off
        with ConfContext() as conf:
            source = conf.source
            dbfile = conf.dbfile
            folder = Path(dir) if isinstance(dir, str) else conf.folder
        root = folder.joinpath(source).expanduser().absolute()
        man3 = root.joinpath("man3")
        html = root.joinpath("html")
        if not html.exists():
            return f"{html} is not eixst, run cache command first."
        if not html.is_dir():
            return f"{html} is not a directory"

        try:
            records = Utils.query(source, dbfile)
        except AssertionError as e:
            return print(str(e), file=sys.stderr)

        records = filter(lambda r: html.joinpath(f"{r.id}.html").exists(), records)
        if not force:
            records = filter(lambda r: not man3.joinpath(f"{r.id}.man").exists(), records)  # fmt: off

        records = list(records)
        if len(records) == 0:
            return print("Nothing to parse.")

        if interact:
            with FzfContext("-m") as fzf:
                assert fzf.add_option(*records)
                selected = fzf.get_selection()
                if len(selected) == 0:
                    return print("Canceled.")
                records = [records[Record.parse_id(s) - 1] for s in selected]

        man3.mkdir(parents=True, exist_ok=True)
        total, process = len(records), Utils.html_handler(source)
        for r in tqdm(records, desc="Processing", total=total, file=sys.stdout):
            document = Utils.read_file(html.joinpath(f"{r.id}.html"))
            try:
                document = process(document)
            except AssertionError as e:
                print(f"{e}, record={r}", file=sys.stderr)
            except Exception as e:
                print(f"record={r}, Unexpected error {e}", file=sys.stderr)
            else:
                Utils.write_file(man3.joinpath(f"{r.id}.man"), document)


if __name__ == "__main__":
    import fire

    fire.Fire(CppRef, name="cppref")
